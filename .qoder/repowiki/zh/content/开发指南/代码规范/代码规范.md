# 代码规范

<cite>
**本文档引用的文件**  
- [factory.ts](file://manga-creator/src/lib/ai/factory.ts)
- [configStore.ts](file://manga-creator/src/stores/configStore.ts)
- [use-toast.ts](file://manga-creator/src/hooks/use-toast.ts)
- [types.ts](file://manga-creator/src/lib/ai/types.ts)
- [skills.ts](file://manga-creator/src/lib/ai/skills.ts)
- [index.ts](file://manga-creator/src/types/index.ts)
- [deepseek.ts](file://manga-creator/src/lib/ai/providers/deepseek.ts)
- [openai.ts](file://manga-creator/src/lib/ai/providers/openai.ts)
- [gemini.ts](file://manga-creator/src/lib/ai/providers/gemini.ts)
- [button.tsx](file://manga-creator/src/components/ui/button.tsx)
- [projectStore.ts](file://manga-creator/src/stores/projectStore.ts)
- [storyboardStore.ts](file://manga-creator/src/stores/storyboardStore.ts)
- [storage.ts](file://manga-creator/src/lib/storage.ts)
- [package.json](file://manga-creator/package.json)
- [tsconfig.json](file://manga-creator/tsconfig.json)
</cite>

## 目录
1. [简介](#简介)
2. [项目结构](#项目结构)
3. [TypeScript类型使用规范](#typescript类型使用规范)
4. [React函数式组件编写约定](#react函数式组件编写约定)
5. [Zustand Store设计模式](#zustand-store设计模式)
6. [AI服务集成规范](#ai服务集成规范)
7. [Shadcn/ui组件封装规范](#shadcnui组件封装规范)
8. [自定义Hook开发标准](#自定义hook开发标准)
9. [状态分层与持久化设计](#状态分层与持久化设计)
10. [错误处理与日志规范](#错误处理与日志规范)
11. [测试规范](#测试规范)
12. [总结](#总结)

## 简介
本规范文档旨在为AI漫画创作工具项目建立统一的代码编写标准，确保团队协作的一致性和代码的可维护性。文档涵盖TypeScript类型系统使用、React组件开发、Zustand状态管理、AI服务集成、UI组件封装和自定义Hook开发等多个维度，通过具体代码示例和设计模式说明，为开发者提供清晰的指导原则。

## 项目结构
项目采用功能模块化组织结构，主要分为组件、状态管理、AI服务和工具库四大模块。这种结构有利于职责分离和代码复用。

```mermaid
graph TB
subgraph "核心模块"
A[components] --> B[ui]
A --> C[editor]
D[stores] --> E[configStore]
D --> F[projectStore]
D --> G[storyboardStore]
H[lib] --> I[ai]
H --> J[storage]
H --> K[utils]
L[hooks] --> M[use-toast]
end
subgraph "AI服务模块"
I --> N[providers]
I --> O[factory]
I --> P[skills]
I --> Q[types]
end
subgraph "UI组件模块"
B --> R[button]
B --> S[card]
B --> T[dialog]
B --> U[dropdown-menu]
end
subgraph "状态管理模块"
E --> V[Zustand]
F --> V
G --> V
end
E --> I
F --> J
G --> J
M --> B
```

**图示来源**
- [factory.ts](file://manga-creator/src/lib/ai/factory.ts)
- [configStore.ts](file://manga-creator/src/stores/configStore.ts)
- [use-toast.ts](file://manga-creator/src/hooks/use-toast.ts)
- [projectStore.ts](file://manga-creator/src/stores/projectStore.ts)

## TypeScript类型使用规范
项目采用TypeScript进行类型安全的开发，通过接口定义和联合类型确保数据结构的清晰性和一致性。

### 接口命名规范
接口命名采用PascalCase格式，以`I`前缀开头（可选），并使用具体语义名称。核心数据模型如`Project`、`Scene`等在`types/index.ts`中统一定义。

```mermaid
classDiagram
class Project {
+id : string
+title : string
+summary : string
+style : string
+protagonist : string
+workflowState : WorkflowState
+currentSceneOrder : number
+createdAt : string
+updatedAt : string
}
class Scene {
+id : string
+projectId : string
+order : number
+summary : string
+sceneDescription : string
+actionDescription : string
+shotPrompt : string
+status : SceneStatus
+notes : string
}
class UserConfig {
+provider : ProviderType
+apiKey : string
+baseURL? : string
+model : string
}
class AIResponse {
+content : string
+tokenUsage? : TokenUsage
}
class TokenUsage {
+prompt : number
+completion : number
+total : number
}
Project "1" *-- "0..*" Scene : 包含
UserConfig --> ProviderType : 使用
AIResponse --> TokenUsage : 可选引用
```

**图示来源**
- [index.ts](file://manga-creator/src/types/index.ts)
- [types.ts](file://manga-creator/src/lib/ai/types.ts)

### 联合类型处理
项目中广泛使用联合类型来表示有限的状态集合，如工作流状态、分镜状态和AI提供商类型。这些类型在`types/index.ts`中定义，确保类型安全和代码可读性。

```mermaid
stateDiagram-v2
[*] --> IDLE
IDLE --> DATA_COLLECTING
DATA_COLLECTING --> DATA_COLLECTED
DATA_COLLECTED --> SCENE_LIST_GENERATING
SCENE_LIST_GENERATING --> SCENE_LIST_EDITING
SCENE_LIST_EDITING --> SCENE_LIST_CONFIRMED
SCENE_LIST_CONFIRMED --> SCENE_PROCESSING
SCENE_PROCESSING --> ALL_SCENES_COMPLETE
ALL_SCENES_COMPLETE --> EXPORTING
EXPORTING --> IDLE
state "工作流状态" as WorkflowState
```

**图示来源**
- [index.ts](file://manga-creator/src/types/index.ts#L6-L15)

## React函数式组件编写约定
项目采用React函数式组件开发模式，遵循最佳实践和性能优化原则。

### Props解构规范
组件Props应使用解构赋值，并通过接口明确定义类型。对于可选属性，应提供合理的默认值或使用可选链操作符。

```mermaid
flowchart TD
Start([组件入口]) --> ValidateProps["验证Props有效性"]
ValidateProps --> PropsValid{"Props有效?"}
PropsValid --> |否| ReturnNull["返回null或默认UI"]
PropsValid --> |是| ExtractProps["解构Props属性"]
ExtractProps --> ApplyDefaults["应用默认值"]
ApplyDefaults --> RenderUI["渲染UI组件"]
RenderUI --> HandleEvents["处理事件回调"]
HandleEvents --> UpdateState["更新组件状态"]
UpdateState --> End([组件出口])
```

**图示来源**
- [button.tsx](file://manga-creator/src/components/ui/button.tsx)
- [ProjectCard.tsx](file://manga-creator/src/components/ProjectCard.tsx)

### useCallback与useMemo使用时机
`useCallback`用于记忆化事件处理函数，防止不必要的重新渲染；`useMemo`用于计算昂贵的值，避免重复计算。

```mermaid
sequenceDiagram
participant Parent as "父组件"
participant Child as "子组件"
participant Memo as "useMemo"
participant Callback as "useCallback"
Parent->>Parent : 渲染
Parent->>Memo : 计算复杂值
Memo-->>Parent : 返回记忆化值
Parent->>Callback : 创建事件处理器
Callback-->>Parent : 返回记忆化函数
Parent->>Child : 传递记忆化值和函数
Child->>Child : 接收Props
Child->>Child : 渲染UI
Note over Parent,Child : 避免子组件不必要重渲染
```

**图示来源**
- [Editor.tsx](file://manga-creator/src/components/Editor.tsx)
- [SceneRefinement.tsx](file://manga-creator/src/components/editor/SceneRefinement.tsx)

## Zustand Store设计模式
项目采用Zustand进行状态管理，遵循原子化store划分和单一职责原则。

### 原子化Store划分
状态被划分为多个独立的store，每个store负责特定领域的状态管理，如配置、项目和分镜状态。

```mermaid
classDiagram
class ConfigStore {
+config : UserConfig | null
+isConfigured : boolean
+loadConfig() : void
+saveConfig(config) : void
+clearConfig() : void
+testConnection(config) : Promise~boolean~
}
class ProjectStore {
+projects : Project[]
+currentProject : Project | null
+isLoading : boolean
+loadProjects() : void
+createProject(data) : Project
+updateProject(id, updates) : void
+deleteProject(id) : void
}
class StoryboardStore {
+scenes : Scene[]
+currentSceneId : string | null
+isGenerating : boolean
+loadScenes(projectId) : void
+addScene(projectId, data) : Scene
+updateScene(projectId, id, updates) : void
+deleteScene(projectId, id) : void
}
ConfigStore --> storage : 持久化
ProjectStore --> storage : 持久化
StoryboardStore --> storage : 持久化
ConfigStore --> AIProviderFactory : 依赖
```

**图示来源**
- [configStore.ts](file://manga-creator/src/stores/configStore.ts)
- [projectStore.ts](file://manga-creator/src/stores/projectStore.ts)
- [storyboardStore.ts](file://manga-creator/src/stores/storyboardStore.ts)

### 异步Action处理
异步操作在store中通过async/await模式处理，确保状态更新的原子性和错误处理的完整性。

```mermaid
sequenceDiagram
participant Component as "组件"
participant Store as "Zustand Store"
participant API as "AI服务"
Component->>Store : 调用异步Action
Store->>Store : 设置加载状态
Store->>API : 发起异步请求
API-->>Store : 返回响应
Store->>Store : 处理响应数据
Store->>Store : 更新状态
Store-->>Component : 完成Action
Note over Store : 统一错误处理和状态管理
```

**图示来源**
- [configStore.ts](file://manga-creator/src/stores/configStore.ts#L45-L56)
- [projectStore.ts](file://manga-creator/src/stores/projectStore.ts#L24-L32)

## AI服务集成规范
项目采用工厂模式实现多AI提供商的适配，确保服务的可扩展性和可维护性。

### 工厂模式实现
`AIFactory`类通过工厂方法创建适配不同AI提供商的客户端，实现服务的解耦和动态切换。

```mermaid
classDiagram
class AIFactory {
+createClient(config) : AIClient
}
class AIClient {
-provider : AIProvider
-config : UserConfig
+providerName : string
+chat(messages) : Promise~AIResponse~
+streamChat(messages) : AsyncGenerator~string~
}
class AIProvider {
<<interface>>
+name : string
+chat(messages, config) : Promise~AIResponse~
+streamChat(messages, config) : AsyncGenerator~string~
}
class DeepSeekProvider {
+name : string
+chat() : Promise~AIResponse~
+streamChat() : AsyncGenerator~string~
}
class OpenAICompatibleProvider {
+name : string
+chat() : Promise~AIResponse~
+streamChat() : AsyncGenerator~string~
}
class GeminiProvider {
+name : string
+chat() : Promise~AIResponse~
+streamChat() : AsyncGenerator~string~
}
AIFactory --> AIClient : 创建
AIClient --> AIProvider : 依赖
AIProvider <|-- DeepSeekProvider : 实现
AIProvider <|-- OpenAICompatibleProvider : 实现
AIProvider <|-- GeminiProvider : 实现
```

**图示来源**
- [factory.ts](file://manga-creator/src/lib/ai/factory.ts)
- [types.ts](file://manga-creator/src/lib/ai/types.ts)
- [deepseek.ts](file://manga-creator/src/lib/ai/providers/deepseek.ts)
- [openai.ts](file://manga-creator/src/lib/ai/providers/openai.ts)
- [gemini.ts](file://manga-creator/src/lib/ai/providers/gemini.ts)

### 多提供商适配
通过统一的`AIProvider`接口，不同提供商的实现可以无缝替换，新提供商的添加只需实现接口并注册到工厂中。

```mermaid
flowchart TD
Start([请求AI服务]) --> CheckConfig["检查配置完整性"]
CheckConfig --> ConfigValid{"配置有效?"}
ConfigValid --> |否| ThrowError["抛出配置错误"]
ConfigValid --> |是| CreateProvider["创建AI提供商实例"]
CreateProvider --> ProviderType{"提供商类型"}
ProviderType --> |deepseek| CreateDeepSeek["创建DeepSeekProvider"]
ProviderType --> |openai-compatible| CreateOpenAI["创建OpenAICompatibleProvider"]
ProviderType --> |gemini| CreateGemini["创建GeminiProvider"]
ProviderType --> |其他| ThrowUnsupported["抛出不支持错误"]
CreateDeepSeek --> CreateClient["创建AIClient"]
CreateOpenAI --> CreateClient
CreateGemini --> CreateClient
CreateClient --> ExecuteRequest["执行AI请求"]
ExecuteRequest --> ReturnResponse["返回响应"]
ReturnResponse --> End([服务完成])
```

**图示来源**
- [factory.ts](file://manga-creator/src/lib/ai/factory.ts#L8-L19)

## Shadcn/ui组件封装规范
项目基于Shadcn/ui进行UI组件封装，遵循可访问性和可定制性原则。

### 组件变体定义
使用`class-variance-authority`定义组件变体，确保样式的一致性和可维护性。

```mermaid
classDiagram
class Button {
+className : string
+variant : 'default' | 'destructive' | 'outline' | 'secondary' | 'ghost' | 'link'
+size : 'default' | 'sm' | 'lg' | 'icon'
+asChild : boolean
}
class buttonVariants {
+default : "bg-primary text-primary-foreground..."
+destructive : "bg-destructive text-destructive-foreground..."
+outline : "border border-input bg-background..."
+secondary : "bg-secondary text-secondary-foreground..."
+ghost : "hover : bg-accent hover : text-accent-foreground"
+link : "text-primary underline-offset-4 hover : underline"
+defaultVariants : {variant : 'default', size : 'default'}
}
Button --> buttonVariants : 使用
buttonVariants --> cn : 合并类名
```

**图示来源**
- [button.tsx](file://manga-creator/src/components/ui/button.tsx)

### 可访问性支持
组件封装时考虑可访问性，使用`@radix-ui/react-*`组件确保键盘导航和屏幕阅读器支持。

```mermaid
sequenceDiagram
participant User as "用户"
participant Button as "按钮组件"
participant Slot as "@radix-ui Slot"
participant DOM as "DOM元素"
User->>Button : 点击或键盘操作
Button->>Slot : 传递Props
Slot->>DOM : 渲染实际元素
DOM-->>User : 视觉反馈
Button->>Button : 处理onClick事件
Button-->>User : 执行业务逻辑
Note over Button : 支持asChild模式，保持语义化
```

**图示来源**
- [button.tsx](file://manga-creator/src/components/ui/button.tsx#L43-L53)

## 自定义Hook开发标准
项目中的自定义Hook遵循单一职责和可复用性原则，提供清晰的API接口。

### use-toast标准
`use-toast` Hook提供统一的通知系统，支持添加、更新和关闭通知。

```mermaid
classDiagram
class useToast {
+toasts : ToasterToast[]
+toast : (props) => ToastReturn
+dismiss : (id?) => void
}
class ToastReturn {
+id : string
+dismiss : () => void
+update : (props) => void
}
class ToasterToast {
+id : string
+title? : React.ReactNode
+description? : React.ReactNode
+action? : ToastActionElement
+open : boolean
+onOpenChange : (open) => void
}
class ToastAction {
+ADD_TOAST
+UPDATE_TOAST
+DISMISS_TOAST
+REMOVE_TOAST
}
useToast --> ToasterToast : 管理
useToast --> ToastAction : 分发
ToastReturn --> ToasterToast : 引用
```

**图示来源**
- [use-toast.ts](file://manga-creator/src/hooks/use-toast.ts)

### Hook设计原则
自定义Hook应保持纯净，不包含业务逻辑，只负责状态管理和副作用处理。

```mermaid
flowchart TD
Start([Hook调用]) --> Initialize["初始化状态"]
Initialize --> SetupEffects["设置副作用"]
SetupEffects --> Subscribe["订阅状态变化"]
Subscribe --> ReturnAPI["返回API接口"]
ReturnAPI --> HandleActions["处理动作"]
HandleActions --> UpdateState["更新内部状态"]
UpdateState --> NotifyListeners["通知监听器"]
NotifyListeners --> End([Hook运行])
style Start fill:#f9f,stroke:#333
style End fill:#f9f,stroke:#333
```

**图示来源**
- [use-toast.ts](file://manga-creator/src/hooks/use-toast.ts)

## 状态分层与持久化设计
项目采用分层状态管理策略，结合本地存储实现数据持久化。

### 状态分层架构
状态分为UI状态、业务状态和持久化状态三层，每层有明确的职责边界。

```mermaid
graph TB
subgraph "UI层"
A[组件状态] --> B[局部状态]
C[use-toast] --> D[通知状态]
end
subgraph "业务逻辑层"
E[ConfigStore] --> F[AI配置]
G[ProjectStore] --> H[项目数据]
I[StoryboardStore] --> J[分镜数据]
end
subgraph "持久化层"
K[LocalStorage] --> L[加密存储]
M[storage.ts] --> N[数据访问]
end
A --> E
A --> G
A --> I
E --> K
G --> K
I --> K
M --> K
N --> M
```

**图示来源**
- [configStore.ts](file://manga-creator/src/stores/configStore.ts)
- [storage.ts](file://manga-creator/src/lib/storage.ts)

### 持久化实现
使用加密的LocalStorage进行数据持久化，确保用户数据的安全性。

```mermaid
sequenceDiagram
participant Store as "Zustand Store"
participant Storage as "storage.ts"
participant Crypto as "CryptoJS"
participant LocalStorage as "浏览器存储"
Store->>Storage : saveConfig(config)
Storage->>Crypto : encrypt(JSON.stringify(config))
Crypto-->>Storage : 加密数据
Storage->>LocalStorage : 存储加密数据
LocalStorage-->>Storage : 确认存储
Storage-->>Store : 完成
Store->>Storage : getConfig()
Storage->>LocalStorage : 读取加密数据
LocalStorage-->>Storage : 返回加密数据
Storage->>Crypto : decrypt(加密数据)
Crypto-->>Storage : 解密数据
Storage-->>Store : 返回配置对象
```

**图示来源**
- [storage.ts](file://manga-creator/src/lib/storage.ts)
- [configStore.ts](file://manga-creator/src/stores/configStore.ts)

## 错误处理与日志规范
项目采用统一的错误处理机制，确保用户体验和问题可追溯性。

### 错误处理策略
在关键操作点进行错误捕获和处理，提供用户友好的反馈。

```mermaid
flowchart TD
Start([操作开始]) --> TryBlock["try { 操作 }"]
TryBlock --> Success{"成功?"}
Success --> |是| ReturnSuccess["返回成功结果"]
Success --> |否| CatchBlock["catch (error)"]
CatchBlock --> LogError["记录错误日志"]
LogError --> ClassifyError["分类错误类型"]
ClassifyError --> UserError{"用户错误?"}
UserError --> |是| ShowUserMessage["显示用户友好消息"]
UserError --> |否| ReportError["上报严重错误"]
ShowUserMessage --> End([操作完成])
ReportError --> End
ReturnSuccess --> End
style TryBlock fill:#eef,stroke:#333
style CatchBlock fill:#fee,stroke:#333
```

**图示来源**
- [configStore.ts](file://manga-creator/src/stores/configStore.ts#L46-L55)
- [storage.ts](file://manga-creator/src/lib/storage.ts)

### 日志记录规范
在关键路径上添加console.error日志，便于开发调试和问题定位。

```mermaid
sequenceDiagram
participant Component as "组件"
participant Service as "服务"
participant Logger as "控制台"
Component->>Service : 调用服务方法
Service->>Service : 执行业务逻辑
alt 成功路径
Service-->>Component : 返回结果
else 失败路径
Service->>Logger : console.error(错误详情)
Logger-->>Developer : 显示错误
Service-->>Component : 返回默认值或抛出错误
end
```

**图示来源**
- [deepseek.ts](file://manga-creator/src/lib/ai/providers/deepseek.ts#L12-L27)
- [gemini.ts](file://manga-creator/src/lib/ai/providers/gemini.ts#L41-L56)

## 测试规范
项目采用Vitest进行单元测试，确保代码质量和功能正确性。

### 测试覆盖范围
关键业务逻辑、状态管理和AI服务集成都应有相应的测试覆盖。

```mermaid
pie
title 测试覆盖范围
“状态管理” : 40
“AI服务” : 30
“工具函数” : 20
“UI组件” : 10
```

**图示来源**
- [store.test.ts](file://manga-creator/src/stores/store.test.ts)
- [factory.test.ts](file://manga-creator/src/lib/ai/factory.test.ts)
- [storage.test.ts](file://manga-creator/src/lib/storage.test.ts)

### 测试策略
采用测试驱动开发（TDD）原则，先写测试再实现功能。

```mermaid
flowchart LR
A[编写测试用例] --> B[运行测试(失败)]
B --> C[实现功能代码]
C --> D[运行测试]
D --> E{"通过?"}
E --> |否| C
E --> |是| F[重构代码]
F --> G[运行测试]
G --> H{"通过?"}
H --> |否| C
H --> |是| I[提交代码]
```

**图示来源**
- [package.json](file://manga-creator/package.json#L10-L11)

## 总结
本代码规范文档为AI漫画创作工具项目建立了全面的开发标准。通过TypeScript类型系统确保代码的类型安全，React函数式组件约定提升组件的可维护性，Zustand原子化store设计实现高效的状态管理，工厂模式的AI服务集成保证系统的可扩展性，Shadcn/ui组件封装规范统一UI风格，自定义Hook标准提高代码复用率。这些规范共同构成了项目的代码质量基石，为团队协作和项目长期发展提供了有力保障。